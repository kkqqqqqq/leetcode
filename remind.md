
# 双指针
## 移动零
当然可以！以下是这个 **「移动零」快慢指针解法** 的核心思路总结，用清晰、简洁的方式帮你抓住关键点：

---

### ✅ 解题思路关键点总结

#### 1. **目标明确**
> 将数组中所有 `0` 移到末尾，**保持非零元素的相对顺序不变**，且**原地操作**（不使用额外数组）。

---

#### 2. **双指针分工明确**
- **`right`（快指针）**：  
  ➤ 从左到右遍历整个数组，**负责“找”非零元素**。
- **`left`（慢指针）**：  
  ➤ 指向**下一个非零元素应该放置的位置**（即已整理好的非零序列的末尾）。

> 🧠 可以理解为：  
> - `right` 是“侦察兵”，  
> - `left` 是“整理员”。

---

#### 3. **核心操作：发现非零就“安置”**
- 当 `nums[right] != 0` 时：
  - 把它和 `nums[left]` **交换**；
  - 然后 `left += 1`，为下一个非零腾出位置。
- 如果 `nums[right] == 0`，直接跳过（`right` 继续前进）。

> 💡 即使 `left == right`（比如开头就是非零），交换也不影响结果，只是“自己换自己”，安全无副作用。

---

#### 4. **为什么能保持顺序？**
- 因为 `right` **从左到右顺序扫描**，非零元素被发现的顺序 = 原始顺序；
- `left` 总是把它们**依次放到最前面的可用位置**，所以顺序自然保留。

---

#### 5. **为什么 0 会自动到末尾？**
- 所有非零都被“搬”到了前面 `[0, left)` 区间；
- 剩下的 `[left, n)` 区间**没被覆盖**，但其实已经被“跳过”的 0 或通过交换“推”到后面了；
- 最终效果：**非零在前，0 在后**。

> 🔁 本质上是通过交换，把非零“拉”到前面，0 被“挤”到后面。

---

#### 6. **时间 & 空间复杂度**
- **时间复杂度**：`O(n)` —— 只遍历一次数组；
- **空间复杂度**：`O(1)` —— 原地修改，只用两个指针。

---

### 🎯 一句话记住这个方法：
> **“快指针找非零，慢指针给座位；找到一个搬一个，零自然沉到底。”**

---

这个思路不仅适用于“移动零”，也是处理 **“原地过滤 + 保持顺序”** 类问题的经典模板（比如移除特定元素等）。掌握它，举一反三！

## 盛水最多的容器

### 关键思想

移动长板，容器的容量只能减少。因为高是短板固定不变，移动长板只会让宽变窄。
因此，只能移动短板，才有可能找出更大的容量