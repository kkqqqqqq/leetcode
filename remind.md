
# 双指针
## 移动零
当然可以！以下是这个 **「移动零」快慢指针解法** 的核心思路总结，用清晰、简洁的方式帮你抓住关键点：

---

### ✅ 解题思路关键点总结

#### 1. **目标明确**
> 将数组中所有 `0` 移到末尾，**保持非零元素的相对顺序不变**，且**原地操作**（不使用额外数组）。

---

#### 2. **双指针分工明确**
- **`right`（快指针）**：  
  ➤ 从左到右遍历整个数组，**负责“找”非零元素**。
- **`left`（慢指针）**：  
  ➤ 指向**下一个非零元素应该放置的位置**（即已整理好的非零序列的末尾）。

> 🧠 可以理解为：  
> - `right` 是“侦察兵”，  
> - `left` 是“整理员”。

---

#### 3. **核心操作：发现非零就“安置”**
- 当 `nums[right] != 0` 时：
  - 把它和 `nums[left]` **交换**；
  - 然后 `left += 1`，为下一个非零腾出位置。
- 如果 `nums[right] == 0`，直接跳过（`right` 继续前进）。

> 💡 即使 `left == right`（比如开头就是非零），交换也不影响结果，只是“自己换自己”，安全无副作用。

---

#### 4. **为什么能保持顺序？**
- 因为 `right` **从左到右顺序扫描**，非零元素被发现的顺序 = 原始顺序；
- `left` 总是把它们**依次放到最前面的可用位置**，所以顺序自然保留。

---

#### 5. **为什么 0 会自动到末尾？**
- 所有非零都被“搬”到了前面 `[0, left)` 区间；
- 剩下的 `[left, n)` 区间**没被覆盖**，但其实已经被“跳过”的 0 或通过交换“推”到后面了；
- 最终效果：**非零在前，0 在后**。

> 🔁 本质上是通过交换，把非零“拉”到前面，0 被“挤”到后面。

---

#### 6. **时间 & 空间复杂度**
- **时间复杂度**：`O(n)` —— 只遍历一次数组；
- **空间复杂度**：`O(1)` —— 原地修改，只用两个指针。

---

### 🎯 一句话记住这个方法：
> **“快指针找非零，慢指针给座位；找到一个搬一个，零自然沉到底。”**

---

这个思路不仅适用于“移动零”，也是处理 **“原地过滤 + 保持顺序”** 类问题的经典模板（比如移除特定元素等）。掌握它，举一反三！

## 盛水最多的容器

### 关键思想

移动长板，容器的容量只能减少。因为高是短板固定不变，移动长板只会让宽变窄。
因此，只能移动短板，才有可能找出更大的容量


## 接雨水

### 动态规划

对于位置 i，它能接到的雨水高度由「木桶原理」决定：

📌 water[i] = min(左边最高柱子, 右边最高柱子) - 当前柱子高度

如果结果 ≤ 0，说明存不了水 → 取 0
所以最终公式：  water[i] = max(0, min(left_max[i], right_max[i]) - height[i])

优化点在于 如何快速的求 左右两边最高的柱子
预处理每个位置左右两侧的最大高度，利用状态转移公式快速填表
数组	含义	状态转移方程
left[i]	从 0 到 i-1 的最大高度（不含 i）	left[i] = max(left[i-1], height[i-1])
right[i]	从 i+1 到 n-1 的最大高度（不含 i）	right[i] = max(right[i+1], height[i+1])

### 双向双指针
两个指针从两边往中间走，哪边柱子矮就动哪边，用“见过的最高柱子”来决定能不能存水，就能安全又准确地算出总水量。
有点不理解，要重新做一下这个方法
### 单调栈
更是不理解。。。

# 滑动窗口

## 无重复字符的最长子串
用左右指针维护一个无重复字符的滑动窗口，右扩左缩，遇到重复就从左边删除直到安全，实时更新最大长度。

## 不直接比较数组，而是维护一个 differ 变量” 的技巧，在很多滑动窗口题目中都非常有用，尤其是在性能要求高的场景
使用数组维护 两个字符串不同字母的数量的差值，
不直接比较数组，而是维护一个 differ 变量” 的技巧，在很多滑动窗口题目中都非常有用，尤其是在性能要求高的场景