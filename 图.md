# 基本概念
节点、边、权重、度（入度、出度）
子图 生成子图 导出子图
无向图：连通图 连通分量
有向图：强连通，弱连通
邻接表、邻接矩阵


# 数据结构
## 有向无权图
![邻接表、邻接矩阵](./imgs/2.jpeg)

```python
# 邻接表
# graph[x] 存储 x 的所有邻居节点
graph: List[List[int]] = []

# 邻接矩阵
# matrix[x][y] 记录 x 是否有一条指向 y 的边
matrix: List[List[bool]] = []
```
## 有向有权图
```python
# 邻接表
# graph[x] 存储 x 的所有邻居节点以及对应的权重
# 具体实现不一定非得这样，可以参考后面的通用实现
class Edge:
    def __init__(self, to: int, weight: int):
        self.to = to
        self.weight = weight

graph: list[list[Edge]] = []

# 邻接矩阵
# matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻
matrix: list[list[int]] = []
```
# 遍历
一句话总结

图的遍历就是 
多叉树遍历 的延伸，主要遍历方式还是深度优先搜索（DFS）和广度优先搜索（BFS）。

唯一的区别是，树结构中不存在环，而图结构中可能存在环，所以我们需要标记遍历过的节点，避免遍历函数在环中死循环。

由于图结构的复杂性，可以细分为遍历图的「节点」、「边」和「路径」三种场景，每种场景的代码实现略有不同。

遍历图的「节点」和「边」时，需要 visited 数组在前序位置做标记，避免重复遍历；遍历图的「路径」时，需要 onPath 数组在前序位置标记节点，在后序位置撤销标记。


只有有环的图才需要 visited数组和onpath数组，如果没有环，就不需要

## 深度优先
### 遍历图的所有节点
```python
def traverse(graph, s, visited):
    # base case
    if s < 0 or s >= len(graph):
        return
    if visited[s]:
        # 防止死循环
        return
    # 前序位置
    visited[s] = True
    print("visit", s)
    for e in graph.neighbors(s):
        traverse(graph, e.to, visited)
    # 后序位置
```
由于 visited 数组的剪枝作用，这个遍历函数会遍历一次图中的所有节点，并尝试遍历一次所有边，所以算法的时间复杂度是 
O(E+V)，其中 E 是边的总数，V 是节点的总数。
###  遍历图的所有边
``` python 
# 需要一个二维 visited 数组记录被遍历过的边，visited[u][v] 表示边 u->v 已经被遍历过
def traverse_edges(s, visited):
    # base case
    if s is None:
        return
    for neighbor in s.neighbors:
        # 如果边已经被遍历过，则跳过
        if visited[s.id][neighbor.id]:
            continue
        # 标记并访问边
        visited[s.id][neighbor.id] = True
        print(f"visit edge: {s.id} -> {neighbor.id}")
        traverse_edges(neighbor, visited)
```
### 遍历所有路径
```python
# 下面的算法代码可以遍历图的所有路径，寻找从 src 到 dest 的所有路径

# onPath 和 path 记录当前递归路径上的节点
on_path = [False] * len(graph)
path = []

def traverse(graph, src, dest):
    # base case
    if src < 0 or src >= len(graph):
        return
    if on_path[src]:
        # 防止死循环（成环）
        return
    if src == dest:
        # 找到目标节点
        print(f"find path: {'->'.join(map(str, path))}->{dest}")
        return

    # 前序位置
    on_path[src] = True
    path.append(src)
    for e in graph.neighbors(src):
        traverse(graph, e.to, dest)
    # 后序位置
    path.pop()
    on_path[src] = False
```
## 广度优先 BFS
```python
from collections import deque

# 从 s 开始 BFS 遍历图的所有节点，且记录遍历的步数
def bfs(graph, s):
    visited = [False] * len(graph) 
    q = deque([s])
    visited[s] = True
    # 记录从 s 开始走到当前节点的步数
    step = 0
    
    while q:
        sz = len(q)
        for i in range(sz):
            cur = q.popleft()
            print(f"visit {cur} at step {step}")
            for e in graph.neighbors(cur):
                if visited[e.to]: 
                    continue
                q.append(e.to)
                visited[e.to] = True
        step += 1
```
