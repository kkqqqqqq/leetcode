# 动态规划

最优子结构，把「原问题」分解为「若干个重叠的子问题」---状态转移方程
重复子结构，记住过往，减少重复计算---状态表

动态规划算法本质上就是穷举「状态」，然后在「选择」中选择最优解

实际上，动态规划解法确实有两种表现形式：

第一种是带备忘录的递归解法，或称为「自顶向下」的解法，也就是我们上面展示的，一个递归函数带一个 memo 备忘录。

第二种是 DP table 的迭代解法，或称为「自底向上」的解法，也就是你说的，用 for 循环去迭代 dp 数组进行求解。

这两者的本质是一样的，可以互相转化。迭代解法中的那个 dp 数组，就是递归解法中的 memo 数组。




## 框架
```python
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```


## 背包
### 状态转移方程
dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i-1]] --- 01背包
dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]] -----完全背包

### 初始化dp
``` python
# dp[i][j] 的定义如下：若只使用前 i 个物品（可以重复使用），当背包容量为 j 时，有 dp[i][j] 种方法可以装满背包。
dp = [[0] * (amount + 1) for _ in range(len(coins) + 1)]

# 初始化 dp[i][0] 为 1
for i in range(len(coins) + 1):
    dp[i][0] = 1
```
## 股票问题
选择：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。

但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k > 0 的前提下操作。


状态：第一个i是天数，第二个k是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。

```python
dp[i][k][0 or 1]
0 <= i <= n - 1, 1 <= k <= K
n 为天数，大 K 为交易数的上限，0 和 1 代表是否持有股票。
此问题共 n × K × 2 种状态，全部穷举就能搞定。

for 0 <= i < n:
    for 1 <= k <= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)

```

直接解释为“买入行为的最大次数限制”比较好理解，“交易”这个词第一感觉不知道到底是在说买还是卖，虽然文中有意强调买入是一次交易的开始，但是还是会有点迷惑。
然后第三个状态“当前没持有股票”为0、“当前持有股票”为1，就比较好理解了。意义在于区分“买卖买”和“买卖买卖”这两种状态，如果只用k这一个状态的话，k都可以等于2，表示最多买入2次；而当前是否持有股票这个状态，可以区分出当前是刚买完还是刚卖完。
dp[..][2][0]会对应到“买卖买卖”
dp[..][2][1]会对应到“买卖买”

然后状态转移方程对于k的理解就更自然了
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
当前未持有，是不会影响“买入”次数的，因为没有新的“买入”操作发生。所以状态转移中k没有变化。
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
当前持有，如果是今天“买入”的话，就需要从k-1转移过来，因为你当前确实多买入了一次。
就算你当前k = 10（买入行为的最大次数限制为10），在k - 1 = 9的时候不管实际发生了多少次买入，就算只实际发生了一次买入，你当前这个prices[i]的买入操作都是实实在在发生的，所以k要在k - 1的基础上加一。
再举个特例，当k - 1 = 9，最大买入次数限制为9，并且恰好发生了9次“买入”操作。那么当前如果要买入的话，必须要在k - 1的基础上加一使k=10，使得“买入行为的最大次数限制”从9变成10，不然新增的一次“买入”往哪放呢

## 打家劫舍
