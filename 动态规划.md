# 动态规划

最优子结构，把「原问题」分解为「若干个重叠的子问题」---状态转移方程
重复子结构，记住过往，减少重复计算---状态表



实际上，动态规划解法确实有两种表现形式：

第一种是带备忘录的递归解法，或称为「自顶向下」的解法，也就是我们上面展示的，一个递归函数带一个 memo 备忘录。

第二种是 DP table 的迭代解法，或称为「自底向上」的解法，也就是你说的，用 for 循环去迭代 dp 数组进行求解。

这两者的本质是一样的，可以互相转化。迭代解法中的那个 dp 数组，就是递归解法中的 memo 数组。


## 框架
```python
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```


## 背包
### 状态转移方程
dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i-1]] --- 01背包
dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]] -----完全背包

### 初始化dp
``` python
# dp[i][j] 的定义如下：若只使用前 i 个物品（可以重复使用），当背包容量为 j 时，有 dp[i][j] 种方法可以装满背包。
dp = [[0] * (amount + 1) for _ in range(len(coins) + 1)]

# 初始化 dp[i][0] 为 1
for i in range(len(coins) + 1):
    dp[i][0] = 1
```
